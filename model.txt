Model 1 (Simplest)
==================

 * No replication
 * No repartitioning

 Let H := { h_1, h_2, ..., h_m } be m hosts in the cluster.
 Let S := { s_1, s_2, ..., s_n } be n sites at hosts.
 
 Define SH(h_i) = { sites at host h_i }
 
 Let SP := { sp_1, sp_2, ..., sp_p } be p stored procedures.
 Let W  := { T_1, T_2, ..., T_w } be w transactions in workload during the epoch.
 
 Define TSP(T) := stored procedure sp for transaction T
 
 Simplification 1: All queries using a given stored procedure touch the same set of partitions.
 
 Define SPS(sp) := { sites touched by stored procedure sp }
 Define LAT(sp) := avg. execution time of stored procedure sp as observed in previous epoch(s).
 
 Assertion 1: If intersection of SPS(TSP(T_i)) and SPS(TSP(T_j)) is non-empty (i.e. they touch a common site or sites), then T_i and T_j execute serially in some order.  

 /// Get a worst case estimation of the workload execution time
 Define EstimateWorstCaseExecTime(W):
    ssets = [] // sets of serially executing transactions
    foreach site s in S:
        ssets.append({}) // maximum concurrency is number of sites
    foreach transaction t_i in W:
        foreach transaction t_j in W:
            if t_i != t_j and intersection(SPS(TSP(t_i)), SPS(TSP(t_j))) is non-empty:
                sset = find sset which contains t_i or t_j
                if sset is not found:
                    ssets.append({ t_i, t_j })
                elif t_i in sset:
                    sset = sset U { t_j }
                elif t_j in sset:
                    sset = sset U { t_i }
    execTimes = [] // total execution times of transactions in ssets
    foreach sset in ssets:
        execTimes.append(sum of avg. latencies of transactions in sset)

    return maximum execution time in execTimes

Ex. Consider a three sites s_1, s_2 and s_3 and a workload with three transactions T_1, T_2 and T_3.
    T_1 uses all sites, T_2 uses site s_1 and T_3 uses site s_3.
    If the schedule of execution is T_1, T_2, T_3 then T_2 and T_3 may execute concurrently (lowest workload execution time).
    However if the schedule is T_2, T_1, T_3 or T_3, T_1, T_2 then all transactions execute serially (highest workload execution time).
